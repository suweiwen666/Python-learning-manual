# -*- coding: UTF-8 -*-

'''
1.思考下面三条语句。它们会改变A打印出的值吗？
A = "spam"
B = A
B = "shrubbery"
---不：A仍会作为"spam"进行打印。当B赋值为字符串"shrubbery"时，所发生的只是变量B被重新设置为指向了新的字符串对象。
A和B最初共享（即引用或指向）了同一个字符串对象"spam"，但是在Python中这两个变量名从未连接在一起。
因此，设置B为另一个不同的对象对A没有影响。如果这里最后的语句变为B =B+'shrubbery'，也会发生同样的事情。
另外，合并操作创建了一个新的对象作为其结果，并将这个值只赋值给了B。我们永远都不会在原处覆盖一个字符串（数字或元组），因为字符串是不可变的。

2.思考下面三条语句。它们会改变A的值吗？
A = ["spam"]
B = A
B[0] = "shrubbery"
---是：A现在打印为["shrubbery"]。
从技术上讲，我们既没有改变A也没有改变B，我们改变的是这两个变量共同引用（指向）的对象的一部分，通过变量B在原处覆盖了这个对象的一部分内容。
因为A像B一样引用了同一个对象，这个改变也会对A产生影响。

3.这样如何，A会改变吗？
A = ["spam"]
B = A[:]
B[0] = "shrubbery"
---不会：A仍然会打印为［"spam"］。由于分片表达式语句会在被赋值给B前创建一个拷贝，这次对B在原处赋值就不会有影响了。
在第二个赋值语句后，就有了两个拥有相同值的不同列表对象了（在Python中，我们说它们是==的，却不是is的）。
第三条赋值语句会改变指向B的列表对象，而不会改变指向A的列表对象。
'''