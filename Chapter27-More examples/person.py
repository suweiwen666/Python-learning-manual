# -*- coding: UTF-8 -*-


'''
1.当我们从shelve获取一个Manager对象并打印它的时候，显示格式逻辑来自何处？
---在类的最终版本中，Manager最终从单独的classtools模块的AttrDisplay继承其__str__打印方法。
Manager自己没有一个这样的方法，因此，继承查找爬升到其Person超类；由于那里也没有__str__，查找继续向上爬升，并在AttrDisplay中找到它。
类语句的标题行中的圆括号中列出的类名，提供了到更高的超类的链接。

2.当我们从一个shelve获取一个Person对象而没有导入其模块的时候，该对象如何知道它有一个giveRaise方法可供我们调用？
---当实例稍后载入内存中的时候，shelve（实际上，它们使用pickle模块）自动地把该实例重新连接到它创建自的类。
Python从其模块内部重新导入该类，创建一个带有其存储的属性的实例，并且把实例的__class__连接设置到指向其最初的类。
通过这种方式，载入实例自动获取所有其他最初方法（如lastName、giveRaise和__str__），即便我们没有把实例的类导入我们的作用域中。

3.为什么把处理放入方法中而不是在类之外硬编码如此重要？
---把处理放入方法中很重要，这样一来，未来只有一个副本需要修改，并且方法可以在任何实例之上运行。
这就是Python封装的概念，把逻辑封装到接口背后，更好地支持未来的代码维护。如果没有这么做，就会产生代码冗余性，将来代码修改的时候工作就会加倍。

4.为什么通过子类而不是复制并修改最初的代码来定制会更好？
---用子类定制可以减少开发工作。在OOP中，我们通过定制已经做过的事情来编码，而不是复制和修改已有的代码。
这是OOP中真正的“大思路”，因为我们可以通过编写新的子类来很容易地扩展以前的工作，我们可以利用已经做过的事情。
这比每次从头开始编写要好很多，也好过引入多个冗余的代码副本，它们未来可能全部都必须更新。

5.为什么回调一个超类的方法来运行默认操作而不是在子类中复制和修改其代码要更好？
---不管是什么样的情况，复制和修改代码会使未来的潜在工作翻倍。
如果一个子类需要执行超类方法中编写的默认行为，通过超类的名称回去调用最初的方法而不是复制其代码，这种做法要好很多。
这对于超类的构造函数也有效。再次强调，复制代码会产生冗余性，当代码改进的时候这是一个主要的问题。


6.为什么使用__dict__这样的工具来允许一般性地处理对象，而不是为类的每个类型编写更多定制代码要更好？
---通用性工具可以避免硬编码解决方案，而后者必须随着时间推移和类的改进保持与类的其他部分同步。
例如，一个通用的__str__打印方法，不需要在__init__构造函数中每次为实例添加一个新属性的时候都更新。
此外，一个通用的打印方法只由所有出现的类继承，并且只需要在一处修改，即在通用版本中修改，从通用类继承的所有类都会选取它。
再一次说明，删除代码冗余性会减少未来的开发工作；这是类带来的主要好处之一。

7.一般来说，何时可以选择使用对象嵌入和组合而不是继承？
---与直接定制相比较（像Manager特化Person），继承是最佳的代码扩展。
对于多个对象聚合到一个完整的对象，并且由一个控制器层类主导的情况，组合非常实用。
继承向上传递调用以实现复用，组合向下传递以实现委托。继承和组合不是互斥的；嵌入一个控制器中的对象，往往其本身是基于继承来定制的。

8.如何修改本章中的类，从而在Python中实现一个个人联络信息数据库？
---本章中的类可以用作样本代码来实现各种类型的数据库。
基本上，我们可以修改构造函数来记录不同的属性，并提供各种适用于目标应用程序的方法，从而改变用途。
例如，可以使用诸如name、address、birthday、phone、email等属性来构建一个联系人数据库，并且可以采用适合这一用途的方法。
例如，调用名为sendmail的方法的时候，可能会使用Python标准库的smptlib模块来自动向一个联络人发送邮件（参见Python手册或应用层级的图书来了解关于这样的工具的更多细节）。
我们这里编写的AttrDisplay工具可能用来逐字打印对象，因为它有意设计为通用的。这里的大多数shelve数据库代码都可以用来存储对象，只需要稍作修改即可。


'''

class Person:
    def __init__(self, name, job, pay):
        self.name = name
        self.job = job
        self.pay = pay

    def last_name(self):
        return self.name.split()[-1]

    def give_raise(self, persent):
        self.pay = int(self.pay * (1 + persent))