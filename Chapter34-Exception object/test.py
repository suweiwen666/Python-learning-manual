# -*- coding: UTF-8 -*-


'''
1.在Python 3.0中，对于用户定义异常的两个新限制是什么？
---在Python 3.0中，异常必须由类定义（也就是说，引发并捕获一个类实例对象）。
此外，异常类必须派生自内置类BaseException（大多数程序继承自其Exception子类，以支持常规类型的异常的全捕获）。

2.基于类的异常是怎样与处理器匹配的？
---基于类的异常是由超类的关系匹配的：在异常处理器中指定超类，就会捕捉该类的实例，以及类树中任何更低的子类的实例。
因此，你可以把超类想成是一般异常的分类，而子类是该分类中更具体的异常类型。

3.说出把环境信息附加到异常对象上的两种方法。
---我们可以通过在引发的实例对象中填充实例属性，来把环境信息附加到基于类的异常，通常是在一个定制类构造函数中做到这点。
对于较简单的需求，内置异常超类提供了一个构造函数，它将其参数存储到实例上（在args属性中）。
在异常处理器中，我们列出要分配给引发的实例的一个变量，然后，使用这个名称来访问附加的状态信息并调用类中定义的任何方法。

4.说出为异常对象指定出错消息的两种方法。
---基于类的异常中的出错消息可以用一个定制的__str__运算符重载方法来指定。
对于较简单的需求，内置的异常超类自动显示你传递给类构造函数的任何内容。
当显式地打印一个异常对象或将其作为一条出错消息的一部分的时候，像打印和str这样的操作会自动获取异常对象的显示字符串。

5.如今为何不再使用基于字符串的异常？
---因为Guido这么说：它们在Python 2.6和Python 3.0中会删除。
其实，这么做有不少好的理由：基于字符串的异常不支持分类、状态信息或行为继承，不像基于类的异常。
在实际中，这使得基于字符串的异常在开始阶段更易于使用，但那是程序规模小时，一旦程序规模变大，就变得难以使用了。

'''